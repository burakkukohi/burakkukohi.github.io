<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>274</fr:anchor><fr:addr
type="user">nm-0001</fr:addr><fr:route>nm-0001.xml</fr:route><fr:title
text="Representable natural transformation">Representable natural transformation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a small category.
  A natural transformation <fr:tex
display="inline"><![CDATA[f : Y \to  X]]></fr:tex> is called <fr:em><fr:strong>representable</fr:strong></fr:em> if all of its fibers are representable objects, in the following sense: for every <fr:tex
display="inline"><![CDATA[c \in  \mathcal {C}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x \in  X(c)]]></fr:tex>, there is a <fr:tex
display="inline"><![CDATA[d \in  \mathcal {C}]]></fr:tex>, a <fr:tex
display="inline"><![CDATA[p : d \to  c]]></fr:tex>, and a <fr:tex
display="inline"><![CDATA[y \in  Y(D)]]></fr:tex> such that the following square is a pullback:</fr:p>
 
  
  <fr:figure><fr:resource
hash="686d34dd344d1a401f91954529611764"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzMi43NDE5OThwdCcgaGVpZ2h0PScxMTIuNTQ4Njg3cHQnIHZpZXdCb3g9Jy03MiAtNzIgODguNDk0NjY1IDc1LjAzMjQ1OCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFXZ0FBb0FBQUFBQnRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWE4wcW1OdFlYQUFBQUU0QUFBQU5RQUFBRHdBZ1FDc1oyeDVaZ0FBQVhBQUFBTElBQUFEakVyREVxRm9aV0ZrQUFBRU9BQUFBQzhBQUFBMkttOEl2V2hvWldFQUFBUm9BQUFBSGdBQUFDUUdoZ0djYUcxMGVBQUFCSWdBQUFBVUFBQUFGQXZtQUpOc2IyTmhBQUFFbkFBQUFBd0FBQUFNQWVBQ3htMWhlSEFBQUFTb0FBQUFHQUFBQUNBQUNBQmhibUZ0WlFBQUJNQUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZsQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1TbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwR01LUXdNL3dIOHBraDBraHEvZ09GQWM4RkRRMEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtSaktrL1A4UDVFY3dKUC8vLzMvbC93VmdWVUFBQUpib0NTY0FBQUI0MmsyU1Myc1RVUmlHNS8zT3pKbEo1cFpKNW1Kc01wTjI0b3l0N2FRMlRhS2xiZXFsVnFyZ0ZVRVFGYVhxeW9VdTFJMmc0c3FsNEQvUXZTNVVWSEFsNHRxTkMzK0FLMEZLbDdhZVNieHg0SEMreXptOHovc2RDVkp0YTR0ZHBYZlNCVWxDcjl2TEtGMUVoSjRmd2VXeEJaWGJFT2NRN2NEM0xMU2dwa2s2MjIwdm90T0NEZEV3S0FXRFV0TENvTlFubGlIbXc1ZUNFUGxESG40OEt6R0tLb0NwM0xoWUlES0tXZCtyOXU0N3pXUEYrbTVESllQZnVGZFFZR2hocUZ3N2QwMHZnU0pObFFGRHVUbThrSzRtNXBjN1NtM1Nvenc1N0c3VThQU0ZGYmdHaXBZS3hpQnppN1BROVJjZVphZmZoRGFvYUhHUkp4Uk1WUzZyOXNiYWRUMHdYWjFJKzNQQjV0UklqVzhJU3c2emhrbnlWTmxUSkdHTDFCUWVHY0tqZ3lKZ2xzRG1Iby9RL1dkSDRIZjdsUDRQN1FjdVQ3ZzZJanpOa0NhZFFYWm1hQ2xkM3VRS20xSW9UT293K0lNY3c3TG1JblhVbE84cTIzTTRjd2huZXRQczFuZGJ4NGpEWWZJcnAwMURheS80dExMNWxSdldTMWNWY0t3K2xLdlpLdUNPMzkvcjRFU2w5SmRDSUZMQjJYd1B4N1hyeFR6T3ZhaHlaYnc2WUp2WTJzQXJmSkNtUlNEMEMzbGlWcTRmK0gxMGV3TE1WYmxZR1RvaUVpdUVHSFU4bGtQM3VuaGl6SXpzT2xvZHFVMU9HM1BXL0lMSzljd3N6MTA4Zm9idGN5cEh6KzlaQWtZRDJ3YzNmRHowWE95Wm1ya2R0NWFFaTRxenJJTzJUZWpGY1prdUg3NTB3aXNmWXRpZFJMRlQ0WjVabGlTU3hyZldxVVFmcGJhMG1qc3ZsUG5Cb25BMGd1LzlscFZhU01YK1Y1eFFuWWdoZE51OWJ0c1BtQWhiU05JeG52OWpzUWt1MFVpbHh6SkI5OExZSUZOVkNwb1ZkSnB0M2xwMjVvK0F6VG5sNVpOeFppNHdsSnFCK0s0cmszYUJQczh5MkxLVE5SYXJUbGt1QWJYRW54L1Q2ZTNQNTM1eExBU3R0c1hjU05zeEduVVlkbzEydGhQT3JxNmQ4dDBWaG1aOTNkV0t6SzVvTXVTZnJ6ODVXcXpGOG15V0hERDM3MnowQ1kwSjR4Y28vblJyZU5wallHUmdZQURpa0txMGxmSDhObDhabUZrWVFPRHhqNlJtQlAzL00zTTYwM0VnbDRPQkNTUUtBRW0rRERVQWVOcGpZR1JnWUdiNHp3QWtBeGhrL3JzeHB6TUFSVkFBS3dCTXlnTW9BQUFDZGdBQUExQUFIQUpTQUNRQnVnQXFBaFFBS1FBQUFBQUFrZ0VBQVU0QnhuamFZMkJrWUdCZ1pVaGdZR0lBQVVZR05BQUFDbVVBYW5qYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVhVQUFvQUFBQUFCd1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjAwV050WVhBQUFBRTRBQUFBTmdBQUFFUUFoQUZKWjJ4NVpnQUFBWEFBQUFMNUFBQUR3TzNIS0hab1pXRmtBQUFFYkFBQUFERUFBQUEyS2MwSUEyaG9aV0VBQUFTZ0FBQUFJQUFBQUNRRmJBR2NhRzEwZUFBQUJNQUFBQUFVQUFBQUZBeERBS3RzYjJOaEFBQUUxQUFBQUF3QUFBQU1BY29Dd0cxaGVIQUFBQVRnQUFBQUdBQUFBQ0FBQ0FCWWJtRnRaUUFBQlBnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRnlBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUttYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTVZReU0vd0g4cGtoMGtocS9nT0ZBZG1pRFVJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VUU0dBb1lLdi8vaDdJcS92Ly9QL3YvcFAvZFlMVmdBQUQwUHd2SEFBQjQybDJTelc3YlJoaEZlWWZVTUNRdERpbVNROHVXU0pxVWhySmpVOVpQS1ZlV0pkbEdFc0JPWUJoRm5BWUJFZ1JkdFdpeTY2cklKdXVncXhZSXV1dTdKQTlRZEZuME1iS05PcFFMRkMySDRJTGZERERuM0t0QXVWejF5WGZrZDJXcEtGQVpxRzVEVDBVK3g0aUhuT284eGh3TE5hT2lERWR6VE9UL0lROXRaQ0lYNVVUMFlST0dVY2xwanQrbWp1WnNHYWVEM2hUb0JFSUZpeGxqblIyMVhiQ0hFZkhZTlF0c2ZwYnR6b0NNeTdrVE1kWm9ST2FkclJmVkdEOS8vbkRoTHNmK3VTcXlLQ0VkbWxzR2dYWVp2UC8wUkUxMVBIbTZuWXR1NTk4Um11TGdKeTI5QTBVK1pMVmFIWkVwUGlvejVaR2loTjVrTEhKSlk2T1BBcVc4K3FUazRlMlg2dFVxa0ZPSkhFaklJUTk4bXVVNnpjZGxPQ3c5bllicnZYTjhVVWhZK3VnSGxYbFJhdFYwMDZMZ2JDT1BtcWVNUHp3OGVxNnFwMDdqOHFZWUdwNm5hMkNwNmRUMTc3KzJWTmRxdXg5TGVIelV1K2R0dG5FM2FsNjh3Ujl4MEFLV2hXK0JFT2U4eFJNZ3VodjJDYjU2K3UyVjc1NnJaTmM5Zjl5eWFjVnUyb2Ftd1dVNkhQejUxMGEzVThNc1Avd3hHL2NoSkRPVXdlb1RlU3laYnhSbFFjcnFzbW1WWVphTGZEd3A1WXJ3RC9NNnRQRTZORkZoNjdjeVl2RFFYK3VnbGE3cy8rR3ZNbHRIMXN5dmZVMDNUSXFkT2p1NDJGOHk5MWlrOTFWMFBhSDZ6WVliYkUyZExnTk85cThheERVb2tycXpmNW5jOTczalR1K01JQXU3S25GaXVURWZ2SG8zVFp4dXZKeVpPaUZHT0hKWXY0WmVFdTBCNlY0U2t3N2JNVXhDMEQvK1pSSE1hN2hYZXRLVnlRY05wNjhoelpOZVY3VFNkUWxNbFpCWjVlRlE5bmlPRDhwVjFXT1p1c3gyWGhXejRvaXFIS3VYeWg3bkJTYWlhb011UmRIL2VQSVo1RW5LdzNLQmNxSGVhaUJmdm15OXY1NmNBY0kzMnlCdXp4dnB1eWRCdkcwTVQvaFJzMVdYTmV4WWFqT1plWEJsT1RZdE4xdnNsZERxbXhFSUgwNFNheHRoN2hxaDJkYUF0NS9mdkh3TkRIclpEdHhRTzlDYkp0RGJGQS8yQ3RUOTVwVEZOOC80QmVZTFI3cXhCendvYWhoMDYvWHU4VGU3N3FKV1N6ZlMyb3RmWjdhSm1QNE51bGw1K3dBQUFIamFZMkJrWUdBQTRwaDU1NTNqK1cyK01qQ3pNSURBNHg5SnpURDYvLy8vK2t6SG1DNEN1UndNVENCUkFHOEFEZ1lBQUFCNDJtTmdaR0JnWnZqUHdNREFkT3ovLy84WG1MSVlnQ0lvZ0JVQWovb0dDd0xHQUFBQ09nQkxBbHIvL3dLWEFERUNVUUF3QUFBQUFBQm1BT0FCWkFIZ2VOcGpZR1JnWUdCbENHZGdZZ0FCUmdZMEFBQUpoQUJoZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRVUFBb0FBQUFBQktRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wa0dOdFlYQUFBQUU0QUFBQU1nQUFBRHdBM0FBMloyeDVaZ0FBQVd3QUFBRk1BQUFCY0JQT01RSm9aV0ZrQUFBQ3VBQUFBQzBBQUFBMktkc0lCR2hvWldFQUFBTG9BQUFBSHdBQUFDUUZad0g0YUcxMGVBQUFBd2dBQUFBUUFBQUFFQWpMQU50c2IyTmhBQUFER0FBQUFBb0FBQUFLQU9nQVlHMWhlSEFBQUFNa0FBQUFGd0FBQUNBQUJnQTNibUZ0WlFBQUF6d0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQUVDQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1NbUtjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1GUXlNL3dIOHBraDBraHEvZ09GQWJxRERNTUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEthakpVL3Y4UDVHdUE2UDgzLzNlQlZRRUJBSk4vQ1F3QUFIamFKYzQ5VDhKUUdBWGdlKzZMdmJhRVVyNWFBakdvMkZZZ2xvU1BOb0todWhBSDNkREI0S0FrVHNRRVk5d3d4by9SSDhIdUgzQTMvQktkVFhSeUFTOGhaem52R1o2OERPeDJEandRWXpuR1lKbHBvY1NoQ01XVU5RN0hsUW1jRUQ2R01TRU9XbUtYY0hxbGlkaExVNC9hbk8vb1BqRndRMmtNamRIMDllOWNOVGd1eHh2cjQ4SE5rLzBvU1hZby9kN1NUMG5WTWtWYUVUcWNvQkdpZzhDRDZ6VDlvUC9zTDhEU3BuK2RCOFY3ZmRDb3EwSWh0dFRPSnZzWEE2NVJKSEgwUGZuNGFtbUt5aGxiK0lWNWxYZnh6cHJ5SVBtNWpEVDl3TFIwRkMyejNrRUk4aUNhQlFRWlJ4R21sUXI4d0hkY09ZU1FDejZuMFNLUDJHR2xEU3FYaU9lNG9TWHJMV1B0TGJwZXF0WHU5QzJPbGZ1UkNxU3lWYzkxNDIyY3pIcjVDdkZLQko1ZEppcGwweXJSOGZZZVJwYk9iVUxFNXFzSlRadjkvT3JKbUxWWVFEWmwyRDlmdGpqc2VOcGpZR1JnWUFCaTFUV2Nvdkg4Tmw4Wm1Ga1lRT0R4ajZSbUJQMmZrZWt5TTRqTHdjQUVvZ0FQL1FuNkFBQUFlTnBqWUdSZ1lHYjR6OERBd0hTWlFaNUJnY21OQVNpQ0FsZ0FQakFDWlFBQzB3QUFBY2tBZEFISkFFZ0NaZ0FmQUFBQUFBQXdBR0FBdUFBQWVOcGpZR1JnWUdCaE1HTUEwUXhRRWdrQUFBWVpBRDRBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktIN2k0T1RpNU9yek5taUFkbWtwYWl5N2lUL2MyQkcvZzhOMXp6ZzJROFNKaG1JUjUwR0ZTZWZQSVkzNVlSSjZJdjRxYzhjdWFFVWs2RTJmRkxuTEtsUC9JWTVhVWtTZmlQeUpuL1BIZU4vWHQzbG12am8yeDNsMXF2ejFaMzFhTlV4dWREK3ZCT3V2UG5UV3FmQ3JUVjIxL3JWV2hjMTJ3cDZIbXhwME9pMGR4Rk1jRWRsd2s4Mnc1aGIybGtzeEpaNE1tLzZZSFNWMW9uTU12UmhvbFQxRkRMemV0NkZXNmlpTGNhWW9QV0t3dVN3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVA4QUFvQUFBQUFCSVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTjBTMk50WVhBQUFBRTRBQUFBTWdBQUFEd0EzQUEyWjJ4NVpnQUFBV3dBQUFFdEFBQUJUTHdtOUhob1pXRmtBQUFDbkFBQUFDMEFBQUEyS1lnSUEyaG9aV0VBQUFMTUFBQUFId0FBQUNRRkhRR1phRzEwZUFBQUF1d0FBQUFRQUFBQUVBZTJBTEJzYjJOaEFBQUMvQUFBQUFvQUFBQUtBTklBVm0xaGVIQUFBQU1JQUFBQUZ3QUFBQ0FBQmdBemJtRnRaUUFBQXlBQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRDhBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWZNczRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWUtoa1p2Z1A1RE5EcEpIVS9BY0tBd0QrRkExOWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS2FqSlUvdjhQNUd1QTZQODMvM2VCVlFFQkFKTi9DUXdBQUhqYUxjMjlUc0pRQU1YeGUrNHRyWksyMUpiZUd3blFoR0F2SGF5QVFHT2lZSXdteG84NG9Ba09TZ1RVMGNUQnhBY3d2b01ibzg0dXZwT0RreE1XQzNxMi8vSTdCR1EwSlRobGhBaENVdG1TTDBORWZpdHFvNTZCQ2FIYUhqaTZmRmdMOGtEZXI5MXc2SmY3b0x2OURQdE9EL3E5dDYyZDhkbndXcmV1SnMrUGNUeGFVa2d5a0kzRURmNWNjRlV6VVdvbXFtejRhL0NqVnAyTElsQ1ppNjV4Y1VDN1J6WUQzUGtQK1JjSFAwL2pyMk5ib2ZPZnhIU21JVjNBQjZrbEpqT2hoWkJ0ckhPUlZiVWlFcjFEV1FpdEtTTFhWN1dzY0RxMEladWlQa3U4dmp2YjFVb0x5RmxTc1VTbW9GUWJscW0vcEZmS296dExVdlgrTm9YcXVmVE5UZlRpdzNDUElpd0xsd1pHVGpGVXNKUFZnb2VIWlIwZVl4NFdIY1dNUHllR0hyQlpVMDdJTDY5ak9DY0FBQUI0Mm1OZ1pHQmdBT0kxZDROcjQvbHR2akl3c3pDQXdPTWZTYzBJK2o4RFV3TXppTXZCd0FTaUFFckdDeEFBQUFCNDJtTmdaR0JnWnZqUHdNREExTUFnekNEQ3hNRUFGRUVCTEFBdmF3RzhBQUtBQUFBQmpRQmtBWTBBT1FJY0FCTUFBQUFBQUN3QVZnQ21BQUI0Mm1OZ1pHQmdZR0V3WWdEUkRGQVNDUUFBQmJVQU9nQjQya1dNTVcvQ01CQ0Z2NGdFaVhUb1VuVmdBQS9NVnFJd2QyRmdZbVZpQVd5aURIR1FFeUlob1k3OTNUMk1KVzU0K3U2OWR3ZmsvSkx3bklUUG9NOUp5V1I3Y2NZSFg1R25zaTBqNTh4Wk1TRkpaK0lzK0ltY1NuS0luUEhOSmZKVS9FZmtuRFYvbTY2OTNnYnIxYTR6MXJ0ejY4dGliMzNmZEU2VnVnajcxanJyajRNMTZuUlhabXo2c1c1VnBRdGRzYUdqNWNxTkFZdEhzUlBIQkhhY0pmT1VGT3lEMDlOSTZxUlZvc1Y5NTF2SlhlZ2N3eWNqblJOM1VjTW9WNzFvTFcxRkZTNDExVDlqUFM4UEFBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUxLjExOTE0LC02Mi4yODc4Mjkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOS4xOTk2NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuMTE5MTQsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTEuMTE5MTQnIHk9Jy02Mi4yODc4MjknPnk8dHNwYW4geD0nLTQ1LjcyMjcwNSc+KDwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy00MS44NDgzMzEnIHk9Jy02Mi4yODc4MjknPmQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTM2LjY2Mjg5OScgeT0nLTYyLjI4NzgyOSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC43NjEwMiwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjExOTE0LC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUxLjExOTE0JyB5PSctNjIuMjg3ODI5Jz55PHRzcGFuIHg9Jy00NS43MjI3MDUnPig8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNDEuODQ4MzMxJyB5PSctNjIuMjg3ODI5Jz5jPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zNy41MzY5MzUnIHk9Jy02Mi4yODc4MjknPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOC45MDk3M1YtNDcuNDk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ3Ljc0NTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTcuOTQ1MjgsLTMwLjIwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuMTE5MTQsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTEuMTE5MTQnIHk9Jy02Mi4yODc4MjknPnk8dHNwYW4geD0nLTQ2LjgyNjIwMic+KDwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00My43MTI4NTknIHk9Jy02Mi4yODc4MjknPnA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTM5LjYwNTkwMycgeT0nLTYyLjI4NzgyOSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44OTE2MiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuMTE5MTQsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTEuMTE5MTQnIHk9Jy02Mi4yODc4MjknPlk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuMzcwNzksLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS4xMTkxNCwtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01MS4xMTkxNCcgeT0nLTYyLjI4NzgyOSc+WDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTMuNzU1MiAwSDQ3LjgzNjA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA4NjA3LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjguODkyMjcsNC4xNzI5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuMTE5MTQsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuMTE5MTQnIHk9Jy02Mi4yODc4MjknPnk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuMTE5MTQsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuMTE5MTQnIHk9Jy02Mi4yODc4MjknPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEzLjMxNjU2LTU2LjkwNTVINDcuMzE1MjUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuNTY1MjUsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI4LjI5ODU0LC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuMTE5MTQsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuMTE5MTQnIHk9Jy02Mi4yODc4MjknPng8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
   
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

   
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {\operatorname {\mathrm {y}}(d)},
    ne = {Y},
    sw = {\operatorname {\mathrm {y}}(c)},
    se = {X},
    nw/style = {pullback},
    north = {y},
    west = {\operatorname {\mathrm {y}}(p)},
    south = {x},
    east = {f}
  }
]]></fr:resource-source></fr:resource></fr:figure>
 
</fr:mainmatter><fr:backmatter /></fr:tree>