<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>289</fr:anchor><fr:addr
type="user">nm-0001</fr:addr><fr:route>nm-0001.xml</fr:route><fr:title
text="Representable natural transformation">Representable natural transformation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a small category.
  A natural transformation <fr:tex
display="inline"><![CDATA[f : Y \to  X]]></fr:tex> is called <fr:em><fr:strong>representable</fr:strong></fr:em> if all of its fibers are representable objects, in the following sense: for every <fr:tex
display="inline"><![CDATA[c \in  \mathcal {C}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x \in  X(c)]]></fr:tex>, there is a <fr:tex
display="inline"><![CDATA[d \in  \mathcal {C}]]></fr:tex>, a <fr:tex
display="inline"><![CDATA[p : d \to  c]]></fr:tex>, and a <fr:tex
display="inline"><![CDATA[y \in  Y(D)]]></fr:tex> such that the following square is a pullback:</fr:p>
 
  
  <fr:figure><fr:resource
hash="4f3dc4f74e1373266e52397010a295ab"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzMS41Nzg0MzFwdCcgaGVpZ2h0PScxMTIuNTQ4Njg3cHQnIHZpZXdCb3g9Jy03MiAtNzIgODcuNzE4OTU0IDc1LjAzMjQ1OCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1nQUFvQUFBQUFBNGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2haOTBpMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQURNWjJ4NVpnQUFBV1FBQUFCa0FBQUFaTzJ6cnd4b1pXRmtBQUFCeUFBQUFDNEFBQUEyS1dmYXFXaG9aV0VBQUFINEFBQUFId0FBQUNRRkFRRmphRzEwZUFBQUFoZ0FBQUFJQUFBQUNBUkZBQTlzYjJOaEFBQUNJQUFBQUFZQUFBQUdBRElBQUcxaGVIQUFBQUlvQUFBQUZ3QUFBQ0FBQkFBZGJtRnRaUUFBQWtBQUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBREVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBXTWxReWMvOEg4cG01R2RIVS9BY0tBd0RBa2cwYWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpVi8vOUR5UDhkWUQ0REFGY3ZCdFVBQUFBQUFRQVAveTBCNVFISEFCc0FBQUVERGdFbklpOENIZ0UzTWpZL0FnTXpGeFlmQVJZWFBnRTNBZVh3SURvZkdSY2ZCaUl3QkJRY0R4SVYxRmhCSEJjYUN3SUVUVDhCeC8zYVNDd0NBd1ZJRFFZQkdTQW5Nd0hIalR3OVNDSVdMOFNUQUFBQWVOcGpZR1JnWUFCaUx5WEh5bmgrbTY4TXpDd01JUENFd1NjR1FmL1haUXBnUEE3a2NqQXdnVVFCNGNJSU53QUFlTnBqWUdSZ1lPYit6OERBd0JUQXdNOGd3UGlVQVNpQ0FwZ0FPN0VDYVFBQ1VBQUFBZlVBRHdBQUFBQUFNZ0FBZU5wallHUmdZR0Jpa0dFQTBReFFFZ2tBQUFOWkFDSUFlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1rQUFvQUFBQUFBNUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2haMTBhR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQURNWjJ4NVpnQUFBV1FBQUFCa0FBQUFaSnNRVkdKb1pXRmtBQUFCeUFBQUFDOEFBQUEyS1VIYXFHaG9aV0VBQUFINEFBQUFId0FBQUNRRTRnRThhRzEwZUFBQUFoZ0FBQUFJQUFBQUNBUUNBQTVzYjJOaEFBQUNJQUFBQUFZQUFBQUdBRElBQUcxaGVIQUFBQUlvQUFBQUZ3QUFBQ0FBQkFBZGJtRnRaUUFBQWtBQUFBRFRBQUFCUHFrcmRkdHdiM04wQUFBREZBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVltU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBXTWxReWMvNEg4cGs1R2RIVS9BY0tBd0MwTlF6MWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpVi8vOUR5UDhkWUQ0REFGY3ZCdFVBQUFBQUFRQU8veXdCeVFISEFCc0FBQUVERGdFbklpOEJIZ0V6RmpZL0FRTXpId0lXRnlZM05qYzJOd0hKNEI4NkdpVWxCaGNyRGdvZEV5WEhVVGdjSWhrR0FRb0hFQnhNQWNmOTNFd3JBZ2hEQ1FnQ0V5dGNBY2VBUlZsRktnc3JHaTlTdkFBQWVOcGpZR1JnWUFEaXRRS0owdkg4Tmw4Wm1Ga1lRT0FKZzA4TWd2NnZ3NlRGZUJ6STVXQmdBb2tDQU9RYkNDTUFlTnBqWUdSZ1lPYjh6OERBd0tURndNZkF6M2lTQVNpQ0FwZ0FOWDBDSXdBQ0tnQUFBZGdBRGdBQUFBQUFNZ0FBZU5wallHUmdZR0Jpa0dFQTBReFFFZ2tBQUFOWkFDSUFlTnBOanJGcXd6QVFoajlUMjFDMzBLa2RPaFJOR1lXTit3Q0ZESm15Wml3a2tUQXVXQTZTWS9CUytnQjU2RndVRGIyRG4wLy8vWGNJcVBnbDQxWVpMMUZ2bFZQSzY4NEZUN3dtTHFWVjRvcDNWanlRNVkvaWZQQ1ZPT2VaNzhRRmIvd2tMc1gvUzF6eHlXVTlEcWZ6WkwzYWpzWjZkeHhDYU9xZDlhRWZuV3AwZlRjMjFsbS9uNnhSaDBXWnVROXpONmhXMTdwbHpjakFpVE1URmk4LzI0cGpJanVPTWd2U0RUVzc2QVY2bVR2Sk5XaHgveWMya25BeHRZL1hqS1FPTEtLR1dmYUNhQ2Q1UlJ0M05lMFYvZ2d3K3dCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5nQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTno3R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDZ0FBQUFyS0FDSGFSb1pXRmtBQUFDQkFBQUFDMEFBQUEyS1pmYnRXaG9aV0VBQUFJMEFBQUFId0FBQUNRRWp3RzhhRzEwZUFBQUFsUUFBQUFLQUFBQUNnUkdBR1JzYjJOaEFBQUNZQUFBQUFnQUFBQUlBQ3dBVm0xaGVIQUFBQUpvQUFBQUZ3QUFBQ0FBQlFBWmJtRnRaUUFBQW9BQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRFVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXZNYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWU5Ca1p2Z1A1RE5EcEpIVS9BY0tBd0R2a1EwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaRWo1ejhBWXdzekFJTTdBd0NxaXBLYXV4Mml1Wm1adXgyakV6OGpIS000bUpNOG94aGdzbG15b0tjUElLS05tbUNiR3lCUG53Y2prRXMvUC9JMHJLVDVpbGEzVHd0RGtWQjZCeEQvdGxmLytwUWl5TUFBQkk0TWwwRnhOaUxtTVltenNmSXhLcGtCVDFVM1U5Qm5Wek0yTXhNVGxHQmsxd0NhSzhzWjZNUVg3Q0RFek1vcUM3V0dBbXBqMHQzWGhCMThoRmlhd1BRQVZKQ0ZNZU5wallHUmdZQURpOXgvakg4ZnoyM3hsWUdaaEFJRW5ERDR4Q1BvL0ExTURNNGpMd2NBRW9nQXlLQWx4QUFBQWVOcGpZR1JnWUdiNHo4REF3TlRBWU1sZ3lSakNBQlJCQVV3QU8yd0NVQUFDZ0FBQUFZMEFaQUE1QUFBQUFBQUFBQ3dBVm5qYVkyQmtZR0JnWnBCZ0FORU1VQklKQUFBREVBQWZBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWFVBQW9BQUFBQUJ3UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMDBXTnRZWEFBQUFFNEFBQUFOZ0FBQUVRQWhBRkpaMng1WmdBQUFYQUFBQUw1QUFBRHdPM0hLSFpvWldGa0FBQUViQUFBQURFQUFBQTJLZHpidFdob1pXRUFBQVNnQUFBQUlBQUFBQ1FGYkFHY2FHMTBlQUFBQk1BQUFBQVVBQUFBRkF4REFLdHNiMk5oQUFBRTFBQUFBQXdBQUFBTUFjb0N3RzFoZUhBQUFBVGdBQUFBR0FBQUFDQUFDQUJZYm1GdFpRQUFCUGdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGeUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtS21hY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NVlF5TS93SDhwa2gwa2hxL2dPRkFkbWlEVUlBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVRTR0FvWUt2Ly9oN0lxL3YvL1Avdi9wUC9kWUxWZ0FBRDBQd3ZIQUFCNDJsMlN6VzdiUmhoRmVZZlVNQ1F0RGltU1E4dVdTSnFVaHJKalU5WlBLVmVXSmRsR0VzQk9ZQmhGbkFZQkVnUmR0V2l5NjZySUp1dWdxeFlJdXV1N0pBOVFkRm4wTWJLTk9wUUxGQzJINElMZkRERG4zS3RBdVZ6MXlYZmtkMldwS0ZBWnFHNURUMFUreDRpSG5Pbzh4aHdMTmFPaURFZHpUT1QvSVE5dFpDSVg1VVQwWVJPR1VjbHBqdCttanVac0dhZUQzaFRvQkVJRml4bGpuUjIxWGJDSEVmSFlOUXRzZnBidHpvQ015N2tUTWRab1JPYWRyUmZWR0Q5Ly9uRGhMc2YrdVNxeUtDRWRtbHNHZ1hZWnZQLzBSRTExUEhtNm5ZdHU1OThSbXVMZ0p5MjlBMFUrWkxWYUhaRXBQaW96NVpHaWhONWtMSEpKWTZPUEFxVzgrcVRrNGUyWDZ0VXFrRk9KSEVqSUlROThtdVU2emNkbE9DdzluWWJydlhOOFVVaFkrdWdIbFhsUmF0VjAwNkxnYkNPUG1xZU1Qenc4ZXE2cXAwN2o4cVlZR3A2bmEyQ3A2ZFQxNzcrMlZOZHF1eDlMZUh6VXUrZHR0bkUzYWw2OHdSOXgwQUtXaFcrQkVPZTh4Uk1ndWh2MkNiNTYrdTJWNzU2clpOYzlmOXl5YWNWdTJvYW13V1U2SFB6NTEwYTNVOE1zUC93eEcvY2hKRE9Vd2VvVGVTeVpieFJsUWNycXNtbVZZWmFMZkR3cDVZcndEL002dFBFNk5GRmg2N2N5WXZEUVgrdWdsYTdzLytHdk1sdEgxc3l2ZlUwM1RJcWRPanU0MkY4eTkxaWs5MVYwUGFINnpZWWJiRTJkTGdOTzlxOGF4RFVva3JxemY1bmM5NzNqVHUrTUlBdTdLbkZpdVRFZnZIbzNUWnh1dkp5Wk9pRkdPSEpZdjRaZUV1MEI2VjRTa3c3Yk1VeEMwRC8rWlJITWE3aFhldEtWeVFjTnA2OGh6Wk5lVjdUU2RRbE1sWkJaNWVGUTluaU9EOHBWMVdPWnVzeDJYaFd6NG9pcUhLdVh5aDduQlNhaWFvTXVSZEgvZVBJWjVFbkt3M0tCY3FIZWFpQmZ2bXk5djU2Y0FjSTMyeUJ1enh2cHV5ZEJ2RzBNVC9oUnMxV1hOZXhZYWpPWmVYQmxPVFl0TjF2c2xkRHFteEVJSDA0U2F4dGg3aHFoMmRhQXQ1L2Z2SHdOREhyWkR0eFFPOUNiSnREYkZBLzJDdFQ5NXBURk44LzRCZVlMUjdxeEJ6d29haGgwNi9YdThUZTc3cUpXU3pmUzJvdGZaN2FKbVA0TnVsbDUrd0FBQUhqYVkyQmtZR0FBNHBoNjlmdngvRFpmR1poWkdFRGdDWU5QREl6Ky8vKy9QdE14cG90QUxnY0RFMGdVQUN1REMzTUFBQUI0Mm1OZ1pHQmdadmpQd01EQWRPei8vLzhYbUxJWWdDSW9nQlVBai9vR0N3TEdBQUFDT2dCTEFsci8vd0tYQURFQ1VRQXdBQUFBQUFCbUFPQUJaQUhnZU5wallHUmdZR0JsQ0dkZ1lnQUJSZ1kwQUFBSmhBQmhlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS2VyYnRtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGlQZWIrL0g4OXQ4WldCbVlRQ0JKd3crTVFqNlB5UFRaV1lRbDRPQkNVUUJBQ2xDQ1g0QUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV2dBQW9BQUFBQUJ0QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFhOMHFtTnRZWEFBQUFFNEFBQUFOUUFBQUR3QWdRQ3NaMng1WmdBQUFYQUFBQUxJQUFBRGpFckRFcUZvWldGa0FBQUVPQUFBQUM4QUFBQTJLbjdjYjJob1pXRUFBQVJvQUFBQUhnQUFBQ1FHaGdHY2FHMTBlQUFBQklnQUFBQVVBQUFBRkF2bUFKTnNiMk5oQUFBRW5BQUFBQXdBQUFBTUFlQUN4bTFoZUhBQUFBU29BQUFBR0FBQUFDQUFDQUJoYm1GdFpRQUFCTUFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGbEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtU21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcEdNS1F3TS93SDhwa2gwa2hxL2dPRkFjOEZEUTBBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLUmpLay9QOFA1RWN3SlAvLy8zL2wvd1ZnVlVBQUFKYm9DU2NBQUFCNDJrMlNTMnNUVVJpRzUvM096SmxKNXBaSjVtSnNNcE4yNG95dDdhUTJUYUtsYmVxbFZxcmdGVUVRRmFYcXlvVXUxSTJnNHNxbDREL1F2UzVVVkhBbDR0cU5DMytBSzBGS2w3YWVTYnh4NEhDK3l6bTh6L3NkQ1ZKdGE0dGRwWGZTQlVsQ3I5dkxLRjFFaEo0ZndlV3hCWlhiRU9jUTdjRDNMTFNncGtrNjIyMHZvdE9DRGRFd0tBV0RVdExDb05RbmxpSG13NWVDRVBsREhuNDhLekdLS29DcDNMaFlJREtLV2Qrcjl1NDd6V1BGK201REpZUGZ1RmRRWUdoaHFGdzdkMDB2Z1NKTmxRRkR1VG04a0s0bTVwYzdTbTNTb3p3NTdHN1U4UFNGRmJnR2lwWUt4aUJ6aTdQUTlSY2VaYWZmaERhb2FIR1JKeFJNVlM2cjlzYmFkVDB3WFoxSSszUEI1dFJJalc4SVN3Nnpoa255Vk5sVEpHR0wxQlFlR2NLamd5Smdsc0RtSG8vUS9XZEg0SGY3bFA0UDdRY3VUN2c2SWp6TmtDYWRRWFptYUNsZDN1UUttMUlvVE9vdytJTWN3N0xtSW5YVWxPOHEyM000Y3dobmV0UHMxbmRieDRqRFlmSXJwMDFEYXkvNHRMTDVsUnZXUzFjVmNLdytsS3ZaS3VDTzM5L3I0RVNsOUpkQ0lGTEIyWHdQeDdYcnhUek92YWh5WmJ3NllKdlkyc0FyZkpDbVJTRDBDM2xpVnE0ZitIMTBld0xNVmJsWUdUb2lFaXVFR0hVOGxrUDN1bmhpekl6c09sb2RxVTFPRzNQVy9JTEs5Y3dzejEwOGZvYnRjeXBIeis5WkFrWUQyd2MzZkR6MFhPeVptcmtkdDVhRWk0cXpySU8yVGVqRmNaa3VINzUwd2lzZll0aWRSTEZUNFo1WmxpU1N4cmZXcVVRZnBiYTBtanN2bFBuQm9uQTBndS85bHBWYVNNWCtWNXhRbllnaGROdTlidHNQbUFoYlNOSXhudjlqc1FrdTBVaWx4ekpCOThMWUlGTlZDcG9WZEpwdDNscDI1bytBelRubDVaTnhaaTR3bEpxQitLNHJrM2FCUHM4eTJMS1ROUmFyVGxrdUFiWEVueC9UNmUzUDUzNXhMQVN0dHNYY1NOc3hHblVZZG8xMnRoUE9ycTZkOHQwVmhtWjkzZFdLeks1b011U2Zyejg1V3F6RjhteVdIREQzNzJ6MENZMEo0eGNvL25ScmVOcGpZR1JnWUFEaWtLajlydkg4Tmw4Wm1Ga1lRT0FKZzA4TWd2Ny9tVG1kNlRpUXk4SEFCQklGQUFkQUNhSUFlTnBqWUdSZ1lHYjR6d0FrQXhoay9yc3hwek1BUlZBQUt3Qk15Z01vQUFBQ2RnQUFBMUFBSEFKU0FDUUJ1Z0FxQWhRQUtRQUFBQUFBa2dFQUFVNEJ4bmphWTJCa1lHQmdaVWhnWUdJQUFVWUdOQUFBQ21VQWFuamFUWTZ4YXNNd0VJWS9VOGRRcDlDcEhUb1VUUm1GamZzQWdReVpzbVlzSkpFSURrZ0tzbVBJRXZvQWZlaGVGQTA5d2ZIZGQ3K0VnSm9iQmZjcWVFMzlYaVdWVEErZU1lY3RjeVZIWmE3NVlNRVRSZmtzNXBObDVwSVh2alBQZU9lVXVSTC9rN25taTk5VmNPZkxhS1BhQkdPalB6alh0ODNXeHFFUFhyVzZlWWkxOVRidVJtdlUvcXJNMUEvVDBhbE9ON3BqUmNCeDVzS0lKY3JQTm1KTVlzOUJkbzZlbG9adGNvTk1RVFpLbkJiN1A3R1doRStwWFhyTlNHclBWYnBoa3N3Zy9TaHBSWmZ1YXJvLzMvUXd1d0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zczEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUxLjg5NDg1NywtNjIuMjg3ODI5KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTguODY2MzMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjg5NDg1NywtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01MS44OTQ4NTcnIHk9Jy02Mi4yODc4MjknPnk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ3LjE2MjYwMycgeT0nLTYyLjI4NzgyOSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDMuMjg4MjI5JyB5PSctNjIuMjg3ODI5Jz5kPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0zOC4xMDI3OTYnIHk9Jy02Mi4yODc4MjknPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTguNDI3NjcsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS44OTQ4NTcsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuODk0ODU3JyB5PSctNjIuMjg3ODI5Jz55PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny4xNjI2MDMnIHk9Jy02Mi4yODc4MjknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQzLjI4ODIyOScgeT0nLTYyLjI4NzgyOSc+YzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMzguOTc2ODMyJyB5PSctNjIuMjg3ODI5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTguOTA5NzNWLTQ3LjQ5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00Ny43NDU3NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE3LjE2NjY2LC0zMC4yMDI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjg5NDg1NywtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01MS44OTQ4NTcnIHk9Jy02Mi4yODc4MjknPnk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ4LjM3NzYzNScgeT0nLTYyLjI4NzgyOSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDUuMjY0MjkyJyB5PSctNjIuMjg3ODI5Jz5wPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00MS4xNTczMzYnIHk9Jy02Mi4yODc4MjknPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODkxNjIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjg5NDg1NywtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01MS44OTQ4NTcnIHk9Jy02Mi4yODc4MjknPlk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuMzcwNzksLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS44OTQ4NTcsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTEuODk0ODU3JyB5PSctNjIuMjg3ODI5Jz5YPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMy40MjE4OCAwSDQ3LjgzNjA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA4NjA3LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjguNzI1Niw0LjE3MjkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS44OTQ4NTcsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTEuODk0ODU3JyB5PSctNjIuMjg3ODI5Jz55PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjg5NDg1NywtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01MS44OTQ4NTcnIHk9Jy02Mi4yODc4MjknPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEyLjk4MzIyLTU2LjkwNTVINDcuMzE1MjUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuNTY1MjUsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI4LjEzMTg3LC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuODk0ODU3LC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUxLjg5NDg1NycgeT0nLTYyLjI4NzgyOSc+eDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
   
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

   
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    display/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {\operatorname {\mathsf {y}}(d)},
    ne = {Y},
    sw = {\operatorname {\mathsf {y}}(c)},
    se = {X},
    nw/style = {pullback},
    north = {y},
    west = {\operatorname {\mathsf {y}}(p)},
    south = {x},
    east = {f}
  }
]]></fr:resource-source></fr:resource></fr:figure>
 
</fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>290</fr:anchor><fr:addr
type="user">nm-0004</fr:addr><fr:route>nm-0004.xml</fr:route><fr:title
text="Natural model">Natural model</fr:title><fr:taxon>Definition</fr:taxon><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:em><fr:strong>natural model of type theory</fr:strong></fr:em> on a small category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a <fr:link
type="local"
href="nm-0001.xml"
addr="nm-0001"
title="Representable natural transformation">representable</fr:link> map of presheaves <fr:tex
display="inline"><![CDATA[p : \tilde {\mathcal {U}} \to  \mathcal {U}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>